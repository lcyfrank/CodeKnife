## 基本介绍

本系统针对 iOS 应用程序进行动态分析，查看目标 iOS 应用程序的系统 API 调用情况，并提取应用程序内的数据流向关系，从而对目标 iOS 应用程序的基本行为，敏感操作以及存在安全隐患的行为进行定位。本系统目前仅针对 Objective-C 实现的程序进行分析，至于 Swift 实现的程序，未经过测试验证。

本系统使用已砸壳的 iOS 应用程序的 `.ipa` 文件或 `.app` 文件进行分析。对于 `.ipa` 文件，由于其本质相当于一个压缩文件，则系统首先将其解压至临时目录，提取目录中的 `.app` 文件之后进行进一步分析。之后，根据 iOS 应用程序 `.app` 包结构，解析其内部 `Info.plist` 文件定位二进制可执行文件，以进行应用程序的静态分析。此外，应用程序的 `.app` 目录下还包括应用程序中所使用的动态库可执行文件，为后期递归分析代码提供支持。

## 静态分析

静态分析针对的是 iOS 应用程序的二进制可执行文件。因此，首先需要知道的是 iOS 应用程序的二进制文件格式为 Mach-O 格式，在静态分析的开始，需参考 Mach-O 格式的字段定义文档，对 Mach-O 格式二进制文件中的可执行代码、符号表、包含的类信息等进行分析，为后续静态分析提供支持。

### Fat 二进制格式分析

在现存的大部分 iOS 应用程序二进制可执行文件中，存在着两种不同类型的二进制文件。其中一种即普通的二进制可执行文件，内部包含一整个特定架构的 Mach-O 内容。另一种称为通用二进制可执行文件（Fat 二进制文件），即在该二进制文件中，存在着多个架构（ARM64、ARMv7）的可执行 Mach-O 内容，当应用被加载进内存执行时，操作系统会根据当前处理器的架构选择合适的 Mach-O 内容进行执行。因此，在通用二进制可执行文件当中以一个头部结构体字段（fat_header）为开始，头部结构体存在 `magic` 字段，其取值为一个固定常数 `0xcafebabe`。在头部结构体中，还存在 `nfat_arch` 字段，用来表示通用二进制可执行文件中的 Mach-O 内容数量，即当前通用二进制可执行文件支持的架构数量。在头部结构体字段后面，由多个连续的表示不同架构的结构体（fat_arch）组成，这些结构体包含了支持架构的处理器类型，以及架构 Mach-O 内容在当前通用二进制可执行文件中的偏移量等信息。因此，系统在开始解析二进制文件时，首先根据该字段的值进行判断其是否为通用二进制格式。若其是通用二进制可执行文件，则根据头部结构体的 `nfat_arch` 字段以及架构结构体的信息，将通用二进制可执行文件中包含的多个 Mach-O 内容抽取出来。

### Mach-O 各部分分析

首先，了解 Mach-O 格式的各字段定义。Mach-O 格式由头部字段、加载命令字段（Load Commands）以及数据字段构成。头部字段数据结构包含 `magic` 字段，处理器类型字段和加载命令数量字段（ncmds）等信息。跟在头部字段之后的是加载命令字段。Mach-O 通过加载命令将整个二进制文件分为多个不同的部分，如代码段部分，函数桩部分，符号表部分，动态库加载部分等。加载命令根据作用，分为 `LC_SEGMENT`、`LC_SYMTAB` 等类型，在加载命令中，除包含当前加载命令的类型以及大小之外，还包含每种类型的关键字段，例如 `LC_SEGMENT` 类型的加载命令中，还包含 `nsects` 等与之相关的字段，具体的字段信息可以参考 `xnu` 内核源码获得。在一系列加载命令之后，跟随的是具体的数据字段，这些数据分别为具体的当前应用程序二进制指令代码、当前应用程序的具体类信息，类元数据、当前应用程序使用的函数桩、当前应用程序存在的符号表等。由于 64-bit 与 32-bit 在字段内容，字段数据长度等方面略有不同，因此系统通过 Mach-O 格式头部的 `magic` 字段的值判断其是否为 64-bit 架构。其次，根据头部的 `ncmds` 字段以及特定类型的加载命令的不同定义，解析得到各个不同类型的具体的加载命令信息。考虑到 `LC_SEGMENT`/`LC_SEGMENT_64` 类型的加载命令的数据中由多个不同的 Section 组成，Section 将数据进行进一步的片段划分，包括代码、函数桩、全局偏移量表（GOT）、类方法类型等。因此，系统参考 `xnu` 源码中对 Section 的定义，将加载指令内部的 Section 字段进行提取。

#### 二进制可执行文件中的字符串

在大部分应用程序中，都会存在大量字符串信息，其中包括程序中使用的字符串常量，程序中所调用的类名、方法名、方法类型以及每个类内部定义的属性、变量名等。这些字符串在 Mach-O 格式中存在于不同的字段中，供操作系统在需要时根据地址去提取。

为了后续根据地址提取字符串的方便，系统在对 Mach-O 格式进行分析的过程中，将分布在 Mach-O 不同部分的字符串提取之后进行统一管理。系统目前提取的各部分的字符串信息如下表所示：

| 加载命令 | Section | 字符串含义 | 提取方式 |
| :-------: | :-------: | ------- | ------- |
| LC_LOAD_DYLIB | \ | 动态库中类名 | 根据该加载命令的格式，采用状态机进行提取，具体可参考下一小节 |
| LC_SEGMENT | objc_methtype | 方法类型字符串 | 该 Section 中由多个地址组成，每个地址代表某一方法类型字符串的地址，通过对地址指向的字符串进行提取，获得方法类型字符串 |
| LC_SEGMENT | objc_classname | 当前应用程序中使用的类名字符串 | 该 Section 存储的直接是字符串，这些以 `\0` 为结束，因此使用 `\0` 作为分隔，进行不同字符串的提取 |
| LC_SEGMENT | objc_methname | 当前应用程序中使用的方法名字符串 | 与提取 objc_classname 方法相同 |
| LC_SEGMENT | cstring | 包含当前应用程序中出现的一些常量字符串，以及一些属性类型签名字符串 | 与提取 objc_classname 方法相同 |
| LC_SYMTAB | \ | 为应用程序内符号表，存放关于文件名、函数名、静态变量等名称 | 该加载命令数据为一个表项是 Nlist 结构的列表，其中每个 Nlist 表项存放着其名称在 Mach-O 文件中的偏移量以及该项的其他相关信息（例如 Section 等），通过遍历该加载命令中的 Nlist 表项，获得每一个表项的字符串及其地址进行提取 |

#### 动态库中的类及其关联动态库解析

大多数应用程序在构建时使用了动态库，即在构建过程中，动态库中的指令不直接放入二进制可执行程序，而在程序需要执行动态库中的指令时，动态加载进来。由于 Apple 规定，除系统动态库（UIKit、AVFoundation 等）以外，iOS 的应用程序只能使用自身放在程序包中的动态库，因此在对程序的分析过程中，可以直接获得这些第三方动态库的二进制可执行文件。在程序加载以及执行的过程中，除了加载二进制文件中本身的类之外，还会用到一些动态库中的类，例如 `UIView`、`UILabel` 等系统内置类以及其他第三方引用的动态库中的类。因此，需要了解 Mach-O 动态库绑定机制，并将其引用地址与其名字关联起来。

在 Mach-O 格式中，存在 `LC_LOAD_DYLIB` 的加载命令，该加载命令中存在 Dylib 信息，其中 Dylib 信息包括所加载的动态库的路径、时间戳以及版本信息。首先，系统对该加载命令进行解析，并提取其中动态库所在路径的信息。

之后，提取在当前应用程序中所使用的动态库中的类信息。动态库中使用的类信息位于 Mach-O 格式的 `LC_DYLD_INFO` 类型的加载命令中。在该加载命令数据中，采用状态机的形式对动态库中的类进行加载绑定。根据 Mach-O 动态库的加载绑定机制，系统定义一个状态机，并定义动态库序号（该序号与之前提取的路径相一致），动态库类符号地址（该状态用来提取动态库的类名），动态库的引用地址以及当前分析地址指向偏移等状态进行分析。并根据当前状态以及解析出来的操作对数据进行提取。此外，在该加载命令中，对于操作码使用了 `uleb128` 进行编码，因此在提取过程中，需实现 `uleb128` 解码方法，对操作码进行解码操作。例如解析出操作码为 `BIND_OPCODE_DO_BIND` 时，则将当前动态库类符号与动态库序号进行绑定，并根据之前提取的动态库所在路径信息，可得到动态库类对应的动态库路径。

关于 Mach-O 动态库绑定机制，可参考 <https://stackoverflow.com/questions/8825537/mach-o-symbol-stubs-ios/8836580#8836580> 中的解释。

#### 内置类数据解析

Objective-C 是一门面向对象语言，因此在应用程序中包含大量的类。在 Mach-O 格式中，存在位于 `LC_SEGMENT` 加载命令中的 `objc_classlist` Section，在该 Section 中，存在当前应用程序中使用的自定义类（即非动态库中的类）相关的数据，包括其含有的元类、方法、属性以及内部变量等信息。因此根据其类数据结构的定义，遍历该 Section 中的每一个类结构，获得类的声明结构。在类的声明结构中，可以进一步获得其元类信息，元类可以看成是类的类，即每一个类均是元类的某一个对象，基于这个特性，我们可以从某个类的元类数据中获取该类的类方法。在获得类的声明结构声明结构后，可以根据之前提取的字符串信息，获取该类的名字，此外，根据类的声明结构中的指向，可以获得类的具体数据，其中包括类的方法列表，类的属性列表以及类的内部变量列表等。

在方法列表中，由多个方法组成。每一个方法的定义中，包含方法名、方法签名以及方法的实现地址。方法签名是由一定规则构成的代表方法类型的字符串，可以从方法签名中获得基本的方法返回值和方法参数的长度以及大致类型（例如 id、int、bool 等）。根据以上的方法相关信息，系统构造一个方法数据，并将方法添加到当前类中。

属性（Property）在 Objective-C 中代表自动生成 `getter` 和 `setter` 的成员变量，由关键字 `@property` 进行定义。类中的每一个属性由其属性名以及属性的属性构成。属性的属性由属性编码表示，例如 `@` 表示为 `id` 类型，`#` 表示为 `Class` 类型等。同样，系统将属性名以及属性的属性由以上参考信息提取出来，并添加到当前类中。

内部变量则是在类中不由 `@property` 定义的成员变量，其与属性的区别可以看作不会自动生成 `getter` 和 `setter` 方法。由于对其访问不会通过生成的 `getter` 与 `setter`，因此在后续解析对其访问的过程中略有不同。内部变量由相对于类对象的地址偏移量、名字、类型、大小等数据构成，系统将内部变量的相应数据解析出来，添加到当前类中。

最后，在类的声明结构中，可以得到类的超类声明地址，通过解析超类声明地址，并获取超类的名字，可以将当前类与其超类进行关联，为后续分析做基础。

#### 分类解析

分类是 Objective-C 中的一个特殊的机制，运用分类可以拓展某个类的能力（添加方法），以及修改某个方法的具体行为等。在 Mach-O 格式中同样存在分类的具体信息。

在 Mach-O 格式中，分类存在于 `LC_SEGMENT` 加载命令的 `objc_catlist` Section 中，该 Section 由多个分类信息组成，分类中包含其分类名、主类、实例方法（对象方法）、类方法、协议和实例属性（对象属性）等数据。由于 Objective-C 定义分类中不能定义内部变量，因此分类的数据字段中不包含内部变量。

在 `objc_catlist` Section 中获得每一个分类的声明结构。每一个分类都与一个类相关联，在这里，该类称为分类的主类，分类即拓展主类的行为。对于分类的主类，在分类中有应用程序内置类与动态库中的类两种。对于应用程序内置类，则直接在分类声明结构中提取即可，而对于动态库中的类，分类声明结构中的值为 `0`，因此，需要从提取的动态库的类信息中获得。根据分类声明结构的定义，可以由分类声明结构的地址获得动态库中类的引用地址，再根据该引用地址从动态库类信息中得到动态库中的类名。

对于分类中的实例方法、类方法以及实例属性的提取，则与从内置类中提取相应数据的方法相同，在提取出来将提取到的信息加到分类数据中即可。

#### 静态变量解析

通常的应用程序中会存在一些静态变量，在静态分析过程中同时需要对这些变量进行分析。在 Mach-O 格式中，未初始化的静态变量的引用地址存在于 `LC_SEGMENT` 加载命令的 `.bss` Section 中，静态变量的引用地址与静态变量的变量名是通过 `LC_SYMTAB` 加载命令中的 Nlist 表现进行关联起来的，在通过引用地址获得 Nlist 表项之后，即可通过之前提取的字符串信息，将静态变量的引用地址与变量名关联。

但是当前提取出来的静态变量仅仅提取了其变量名，而没有提取到其具体类型，因此需要进一步分析，找到提取其静态变量类型的方法。由于静态变量是未初始化的，因此在执行的过程中，若使用到该静态变量，则正确情况下会存在指令对该静态变量进行赋值。因此，可以监听对静态变量的赋值，得到赋值时的类型，之后将该类型与静态变量进行关联，则获得对应静态变量的引用地址与静态变量类型的对应关系。

#### 函数解析

除了方法以外，应用程序中也会存在大量函数。函数包括应用内定义的函数和动态库中的函数。对于应用内定义的函数，Mach-O 格式中将这些函数的函数名与函数的引用地址通过 `LC_SYMTAB` 加载命令关联起来。因此，系统通过遍历该加载命令中的 Nlist 表项，并判断 Nlist 表现中的所属 Section 以及 Nlist 的类型，从而提取应用内函数与引用地址的关系。

对于动态库中的函数，Mach-O 格式使用了桩函数的形式对动态库中的函数进行懒加载，所谓桩函数的基本思想即在二进制文件中添加目标函数的占位符，并将对目标函数的调用转向对该占位符的调用。此时占位符的实现仅仅实现一个调用的转移。当第一次调用该函数的时候，占位符将调用转移至一个特定位置，该位置的指令会将动态库中的函数进行加载，并填充至转移位置，这样在之后再调用该函数时，就能转移到正确位置。因此在 Mach-O 的二进制可执行文件中会存在每一个动态库函数对应的函数桩。Mach-O 格式的桩函数位于 `LC_SEGMENT` 的 `stubs` Section 中（32-bit 在 `picsymbolstub4` Section 中），因此通过对该 Section 的提取，则可以得到动态库中的函数引用地址与函数名的关联。

#### Block 的解析（闭包）

在 Objective-C 语言中，使用 Block 数据类型作为代码块进行传递以及调用，与其他语言中的闭包类似。因此，在解析过程中，对 Block 数据类型进行提取分析，以在后续方法分析中判断传递的 Block 内容。

Block 的类型分为 `NSConcreteGlobalBlock`、`NSConcreteStackBlock` 和 `NSConcreteMallocBlock`，对于三种类型的定义可在 Objective-C 的 Runtime 头文件中获得。其中，经过我们的发现，`NSConcreteGlobalBlock` 的内容在 Mach-O 的 `LC_SEGMENT` 的 `const` Section 中定义，可在解析 Mach-O 期间直接获得。通过遍历之前提取的动态库中的类信息，定位到类名为 `NSConcreteGlobalBlock` 的动态类，获得其引用地址，由此可以得到该类型 Block 对象在 Mach-O 中的位置，根据 Block 的数据结构定义，解析出具体的 Block 类型，其中包括 Block 的实现地址等。其他两种类型的 Block，在 Mach-O 格式中没有找到明显的定义，根据调用其的汇编代码可以发现，对于这两种类型的 Block，在执行过程中动态构造了对应的结构体进行传递。因此，为了提取这两种类型的 Block，首先需要获得执行方法的参数类型（参数的获取方法在后面阐述），之后根据参数类型判断其是否包含 Block 参数，若包含 Block 参数，则将该参数的当前各个字段的值，依照 Block 的数据结构定义，将其解析成为对应的 Block，由此进行分析。

此外，系统对于 Block 的存储形式，使用与类方法相一致的方式，将 Block 定义成为一个类，并将 Block 的执行地址定义为该类的某一个方法，进行对所有 Block 统一管理。

### 反编译

Mach-O 格式的代码段位于 `LC_SEGMENT` 类型的加载命令中的 `text` Section。通过该 Section 的指示的值，可以获得 Mach-O 的代码偏移量以及指令代码部分。获得二进制指令代码之后，对其进行反编译以获得汇编代码，供后续分析。

因为之后的分析是基于每一个函数和每一个方法进行的，因此在反编译的过程中需要确定函数和方法边界。对于函数和方法边界的确定，刚开始使用判断当前指令是否为 `ret` 的方法，但是考虑到方法内的控制流跳转（if 和 for 等语句），因此方法内可能有多个 `ret` 指令，遇到 `ret` 也不一定是方法与函数的边界。因此对于方法和函数边界的确定，借用从 Mach-O 格式中提取出来的各个类方法的实现地址以及提取出来的内置函数的地址进行判断，其中包括各个类型的 Block 的实现地址（因为在后续发现，Block 的实现地址也存在于 `LC_SYMTAB` 加载命令中）。

确定了函数于方法的边界地址之后，借助 Capstone 开源工具对二进制指令码进行反编译操作。在反编译过程中，根据反编译获得的指令地址与获得的函数和方法边界地址对比可以将函数与方法进行切分。在反编译过程中，遇到部分 Capstone 可能无法识别的指令，会导致反编译过程突然中断。因此在反编译中断时，需要判断当前指令地址是否已经到达当前二进制可执行文件指令代码部分的终点，从而决定是否继续执行后续反编译的过程。

### 模拟执行

在得到当前应用程序的函数和方法的指令集之后，对每个函数和方法内部的执行以及调用的系统方法进行分析。由于 Objective-C 的方法调用机制，因此在分析每个调用的方法和函数的具体值时，需要得到当前寄存器以及内存中的值，从而分析方法的调用者和具体调用的方法。系统采用模拟执行的方式，并且以每个方法和函数内部为边界，对单个方法和函数采用模拟执行。

#### 构造模拟执行器

为了模拟执行各个指令，首先构造一个轻量的模拟执行器。系统定义一个模拟执行器，并在内部根据 ARM 架构的寄存器类型定义代表寄存器值的内部变量。此外，考虑到现代操作系统架构会频繁操作内存中的数据，包括读数据和写数据，在模拟执行器中添加对内存数据的支持，包括栈这些高级数据结构，跟踪执行过程中对内存的操作。

之后，查询 ARM 架构中的常用的操作码，针对模拟执行器内部的寄存器、内存地址等上下文信息，进行更改执行。目前构造的模拟执行器支持的指令类型有：MOV、ADD、SUB、LDR、STR、ADRP 等。

为了支持后续的方法以及函数内的数据流向分析，还在模拟执行器内部构造执行上下文，用来跟踪方法返回值、方法参数的流向。

在实例化模拟执行器时，还会考虑当前的方法的参数（目前没有办法提取函数中的参数）对模拟执行器的上下文进行初始化，通过从 Mach-O 分析得到的方法签名，得到某格方法的参数类型和参数长度。例如，某个方法有三个 8 位长度的参数时，则模拟执行器会将 `x0`、`x1`、`x2` 寄存器初始化为参数值。

#### 构造基本块

因为通常函数和方法内部有大量的 if 和 for 等控制程序执行流程的语句，直接对函数和方法进行分析会造成控制流分析不当的后果。此外，在一个方法中由于执行流程的跳转，可能有部分指令码不会被执行到，后续分析这部分的指令码是没有必要的。所以，将每个方法和函数都拆分成为基本块进行分析。

基本块即除了入口和出口，只有一条执行流的代码块。首先，对方法和函数的指令集合进行拆分成为基本块。系统根据 ARM 架构下的跳转指令、跳转目标以及跳转规则（有条件和无条件跳转）将函数和方法内部的基本块的拆分地址提取出来。在得到拆分地址后，遍历所有指令，判断其地址，从而完成对基本块的拆分。

在得到基本块之后，对所有的基本块进行可达性判断，即判断该基本块是否可以执行到。首先从方法和函数的入口基本块开始进行分析，考虑到入口基本块对于当前方法和函数一定可以执行到，因此将该块放入可达队列，之后根据该块的后续状态（是否跳转，跳转地址等）将后续可能到达的块放入待分析队列。系统从待分析队列中获得待分析的基本块，并进行相同的判断。知道待分析队列为空，则判断判断结束。在分析过程中，还需要将每个基本块之间的跳转关系考虑进去，使得每个函数和方法内部的可达基本块能够连接起来。

#### 针对基本块模拟执行

获得可达性基本块之后，则开始对每个基本块执行模拟执行。首先从函数和方法的入口基本块开始，将其放入待执行队列，并进行模拟执行。当执行完当前基本块之后，获取其后续执行的基本块（即跳转过去的块和直接执行过去的块），若这些基本块在可达性基本块中，则将这些基本块放入待执行队列里待执行，并且将当前执行上下文（寄存器状态和内存中的值）保存。之后对其后续基本块的分析时，均需将执行上下文恢复到当前基本块执行结束时的状态。

在模拟执行过程中，根据 ARM 架构的函数跳转指令，获得跳转的函数名，并根据函数名，采用不同的方式（objc_msgSendSuper2 和 objc_msgSend 等）。如果当前方法调用为调用父类的某个方法，则提取出当前类的父类名称，并根据相应寄存器的值提取所调用的方法的名称，完成父类方法调用的提取。如果当前为普通的方法调用，则需要根据寄存器的值，对调用对象进行提取。调用的对象有对象本身（self)，之前某个方法的返回值，传进来的参数，静态变量，其他类等。在解析调用对象的过程中，根据不同的规则提取相应的调用对象。因为对于解析调用对象来说，返回值与参数比较重要，因此在下面进行阐述。

在执行过程中，额外增加了对 `NSNotification` 中的发送通知与接受通知的支持。通知在 Objective-C 是一种特殊的事件监听机制，可以通过发送通知以及监听通知作出不同的响应，因此对其进行提取，为后续控制流分析提供支持。

除此之外，有些函数与方法会包含 Block 类型的参数，在本系统的处理中，默认这些 Block 会在当前环境中进行执行。因此，当遇到 Block 参数时，对其进行进一步模拟执行。

#### 参数和返回值提取

在提取调用对象的过程中，某个方法内部的调用，调用对象很大程度上来自另一个方法的返回值，例如下面代码段：

```objective-c
id objc = [[NSObject alloc] init];
[objc doSomething];
```

因此需要对函数和方法的返回值进行调用。对于应用程序内部定义的方法和函数，以及动态库中的方法和函数，可以采用递归执行的方式进行提取。当遇到应用程序内部定义的方法和函数时，首先根据方法签名获取是否存在返回值，若存在返回值，则会获得该函数或方法的指令集，并将该指令集送入模拟执行过程中，直到执行完毕。因为 ARM 架构下会将指针类型（Objective-C 中的对象均以指针形式引用）的返回值存入 `x0` 寄存器，因此可以通过 `x0` 的值来获得返回值类型。对于动态库中的方法和函数，首先根据之前提取的动态库地址，将该动态库的二进制可执行文件进行分析，之后从该动态库中的可执行文件提取对应的函数或方法指令，进行类似的递归执行。

当函数和方法位于系统库中，例如 UIKit 时，则无法进行递归模拟执行。因此系统首先预设多个系统类和系统方法的返回值类型，当遇到系统库中的方法和函数时，从预设的返回值类型中提取相应的返回值。

对于参数的提取，由于无法获得准确的参数类型，仅能通过方法签名获得参数的数据长度，因此在模拟执行对方法的调用过程中进行分析的时候，仅对参数做占位符 `PARAMETER_INDEX` 处理。

#### 数据流的提取

在对程序分析的过程中，需要对每个参数或者返回值的数据流向进行提取，因此在模拟执行的过程中，同时增加数据流动信息的提取。

首先，分析数据流动的来源，分别为当前方法和函数的参数和内部某个方法即参数的返回值。对于数据流的去向，由于在 Mach-O 中，无法准确提取函数的参数个数，因此目前去向仅考虑方法，则去向可以分为方法的调用者和方法的参数。清楚以上划分之后，开始实现数据流的提取。

首先定义执行上下文，在执行上下文中，参考编译原理，定义多个临时变量，用来标识不同的数据，则可以通过该临时变量的流向提取出数据的流动。在初始化执行上下文中，首先根据当前方法的参数数量，将每个参数对应一个临时变量，并将临时变量与寄存器（内存地址）进行绑定。之后，当遇到函数和方法的调用时，判断其是否有返回值，若有返回值，则将该返回值对应于一个临时变量，同时该临时变量与其存放的寄存器绑定。在模拟执行过程中，当寄存器之间进行 MOV 操作，或者寄存器从内存中加载数据以及寄存器将数据存入内存中时，会更新这些临时变量绑定的寄存器和内存地址值。当执行方法时，根据其参数个数从寄存器（内存地址）中判断是否有相应绑定的临时变量，若存在临时变量，则提取一条数据流传输。待模拟执行完当前方法或函数时，方法内部的数据流即提取完毕。

### 控制流程图绘制

根据分析出来的结果，使用 graphviz 开源绘图库进行控制流程图的绘制。首先，每个函数定义为一幅完整的数据流程图。每个函数内部的基本块则转换成为数据流程图中的每一个节点，节点内部则由语句组成。

系统支持生成深入的控制流程图，即当遇到应用程序内定义的方法（函数）或者第三方库中定义的方法（函数）时，会进一步生成该方法（函数）的控制流程图，并将该控制流程图与原来的控制流程图合并。**但是当遇到调用链较长时，会导致生成控制流程图的速度很慢。**

### 安全性分析

针对多个安全性问题，根据造成这些潜在安全性问题的系统函数和方法的调用序列，对安全性进行分析。

* 剪切板的访问：对于剪切板的访问，根据访问剪切板的系统函数和方法，判断某个方法是否有调用这些方法和函数，从而进行剪切板访问的安全性判断。之后考虑加入对剪切板访问的数据流分析，增强判断可靠行。

* 存储方式判断：根据 iOS 开发过程中的常用数据存储方式，根据这些存储方式的系统函数和方法，提取当前应用程序中使用的数据存储方式。

* 后台行为判断：提取 iOS 应用程序进入后台时所调用的系统函数和方法，从而分析 iOS 应用程序进入后台之后的操作。

* 热更新隐患判断：提取 iOS 应用程序中使用 JSContext 类的方法和函数。之后考虑增加 JSContext 赋予的 Objective-C 的行为从而进一步对其热更新隐患进行分析。

## 解决的一些问题

1. 反编译过程中遇到的问题：

发现在反编译过程中，会遇到某些指令（可能是当前框架不支持），导致反编译过程中断，从而使得后续代码无法反编译的情况。解决方法是在反编译停止时，判断其当前指令地址是否已经到达代码段最后一个地址，若不是，则继续反编译下一个地址。

2. 在解析 32-bit 架构时遇到的问题：

32-bit 架构下，地址长度为 4 字节，不同于 64-bit 架构下的 8 字节，因此在解析时若不考虑清楚会出现问题。此外，64-bit 可执行文件的地址通常以 `0x100000000` 开头，而 32-bit 可执行文件没有这个特性。

3. Block 数据的处理

在处理 Block 数据的时候，发现 3 种类型的 Block 数据在 Mach-O 文件中的存在形式不同，因此需要针对 3 中类型的 Block 进行针对性分析

4. 静态变量的类型确定

在 Mach-O 中提取到的静态变量为静态变量的值，而当前所需要的信息是静态变量的类型，因此在模拟执行过程中，获得静态变量的类型，并与相应的静态变量相关联，进行分析

5. 类的内部变量访问

执行过程中，发现对类的内部变量的访问通常采用偏移的方式，因此在对类的变量的处理时，额外采用一个偏移值的数据结构进行存储，从而完成对内部变量访问的分析

6. 反编译速度慢性能优化

将原本的针对 list 的查找变成有序 list 下的元素的单个匹配

7. 
